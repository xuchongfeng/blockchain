# BitCoin: 点对点的电子现金系统

标签（空格分隔）： bitcoin

---

### 摘要
一个存粹的点对点的电子现金可以允许交易双方不经过金融机构进行支付。电子签名可以用于实现该方案，但是如果为了防止双重支付而引入第三方，那么该系统的优势就会丧失。本文提出一种点对点的防止双重支付的方案。交易网络将交易记录在一条`hash`链上，而这条链路是基于工作量机制的（`proof-of-work`），如果不进行工作量的重新计算，是无法修改记录的。交易网络中的最长链不仅作为交易事件的记录，而且确认来自最强`CPU`计算池。只要网络中的大部分节点不串通进行网络攻击，那么就会形成最长的链，而且比攻击者的链更长。同时网络的结构也能简单。消息在网络中进行广播，节点可以自由的加入和离开，并且接受最长的`proof-of-work`链作为事件的记录，直到节点的离开。

### 介绍
网络上的商业基本都是依赖金融机构作为信任的第三方来进行电子支付。虽然这个模型在大部分交易中有效，但是这种信任模型仍然有它固有的弱点。这个系统中交易无法做到完全不可逆，因为金融机构无法避免纠纷调解。调解的成本增加了交易的成本，限制了最小的交易大小，降低了偶然交易的概率，并且损失了为不可逆服务进行不可逆交易的能力。因为可逆的存在，系统就更需要信任。商家就需要更加警惕他们的顾客，需要更加注意他们本不需要注意的信息。一部分诈骗作为不可避免的事实而被接受。这些成本和支付的不确定性可以通过使用物理货币避免。但是目前还没有在通信中，且不存在第三方的情况下，进行支付的解决方案。
真正被需要的是基于加密证明而不是信任的电子支付系统，那么交易双方就可以在没有第三方的情况下完成交易。由于计算成本的存在，将交易取消是不现实的，这样可以保护卖家免受诈骗，同时履约机制可以保护买家。本文提取了一种使用点对点的分布式服务器来解决双重支付问题的方案，每个服务器通过计算证明交易的时间顺序。只要系统中好的结点的计算能力比攻击结点的计算能力强，那么系统就是安全的。
### 交易
我们将电子货币定义为一个电子签名的链条。每个拥有者通过以下方式交易货币：上一次交易进行`hash`的签名，接收者的公钥，将这两者写入货币的末尾。收款人通过签名验证该链的拥有者。
![image_1c2va8db31ie7sjv90lnk6is19.png-44kB][1]

其中的问题是接收者无法确定币的所有者是否进行了多次消费。一个常见的解决方案是引入信任的第三方或者造币厂，对每次交易进行检查。在每次交易之后，货币必须归还到造币厂进行销毁，并发行新的货币，只有从货币产新发行的货币才能确认不被多次消费。这个解决方案的问题是，整个货币系统掌握在造币厂的运营者手中，每一笔交易都必须经过它们，就像银行一样。

需要一种机制让接收者知道该币的拥有者并未消费该币。我们的规则是，最早的消费才是有效的消费。所以系统并不关心后续尝试的多重消费。基于中心造币厂的模型，造币厂知道所有交易的先后顺序。为了不需要该造币厂，所有的交易必须在网络中进行广播。我们需要一个参与者系统对交易顺序达成一致。接收者需要网络中的大部分节点证明它是第一个收到币的。

### 时间戳服务器
我们的解决方案以时间戳服务器为起点。一个时间戳服务器主要进行物品块的`hash`计算，并将`hash`进行广播。时间戳表示数据在当前时间必须存在。所有的时间戳的`hash`中，包含之前的时间戳，形成一个链条。

![image_1c30rolrdn8a1f491m731felkcv16.png-6kB][2]

### 工作量证明
为了实现分布式的点对点的时间戳服务器，我们需要一个工作量系统。工作量是指需要找个一个值，并和当前数据进行`hash`得到一个数。这个数越小，需要进行的工作量成指数级增长。但是可以通过简单的一次`hash`进行校验。

对于时间戳网络，我们通过在块中添加一个随机数来实现。只要这个数被求出，在不进行重算的情况下，这个块的数据无法被修改。那么当在该块数据之后添加了新的块之后，修改该块的代价就会越来越大。

![image_1c30ro3orll5q0qdbg1cm3tnap.png-6.7kB][3]

工作量证明机制同时也解决了决策实体的表示。如果一个`IP`地址一票，那么网络就可能被拥有可以分配IP地址的人破坏。工作量证明机制实际上是一`CPU`一票。网络中的大多数的决定由最长的链代表，因为最长的链意味着最大的`cpu`计算量。如果大部分计算能力集中在好的结点上，那么正确的链就会增长的最快。如果攻击者要修改之前的某一个块，那么它需要重新进行该块以及之后所有块的工作量。可以证明当块被增加时，攻击者能进行攻击的概率是成指数级降低的。

为了补偿硬件速度的增长，以及运行节点的变化，工作量的大小会根据块产生的速度进行调整，如果块增长的太快，难度就会增加。

### 网络
网络的运行步骤是：
- 新的交易在网络中进行广播
- 每一个节点将收集到的交易进行打包成块
- 每一个节点进行计算获取结果以完成块的打包
- 完成块的打包，则该节点在网络中广播该块
- 只有块有效，而且块中所有的交易都没有进行双重支付，该块才会被接受
- 节点接收了该块，就会以该块为基础，进行下一个块的计算

节点总是把最长的链作为有效的链，同时在它的基础上进行扩张。如果两个节点同时广播新的不同的链，那么其它节点可能部分收到这两条链的顺序可能不一样。那么其它节点就会在其中一条链中添加，同时保存另外一条，以防另外一条变的更长。这样的关联只有在一条链变的更长时被打破。节点就会切换链条。

新的交易不需要广播到所有的节点。只要交易被一些节点接受，那么他们就会进入块。同时块的广播也容忍消息丢失。如果节点未收到之前的某个块，它在接收到下一个块时会发现，并且向网络中请求没有收到的那个块。

### 激励
按照惯例，在块中的第一笔交易是一笔特殊的交易，这比交易会产生新的币，并发放给块的生成者。这样的机制激励结点支持网络，并提供了一种将币投入网络流通的方式，因为没有中心的权威机构发行它们。稳定数量的新币投入网络进行流通，就和矿工进行黄金挖矿投入市场一样。在我们的系统中，花费的就是`cpu`时间和电力。

同时，激励也可以来自交易费用。如果交易的输出值小于输入值，那么差值就是生成这个块的交易费用。一旦所有的币进入流通，那么激励就会全部来自该差值。

同时这样的激励方式，也有助于结点成为好的节点。如果一个贪婪的攻击者拥有比系统中好节点更大的`cpu`计算能力，那么它可以选择伪造数据，或者选择遵守规则，获取激励。通过获取激励，它可以获取到更多的币，那么它就会致力于维护系统的稳定以维持它的币。

### 回收磁盘空间
当最近的交易已经写入到块中，而且块以及被很多结点记录。那么花费交易就可以丢弃以节约磁盘空间。同时，为了不破坏块的`hash`。交易的`hash`通过`merkle tree`进行组织，只有根节点保存在块的`hash`中。那么旧的节点就可以通过忽略分支起到压缩的作用。内节点的`hash`就不需要保存。
![image_1c33emsi11jacb4etvdogo1lqd9.png-44.2kB][4]

一个不包含任何交易的块的头部大小为80字节。假设每个块产生的速度是10分钟，那么每年产生的块大小为 $80bytes * 24 * 6 * 365 = 4.2MB$。以2008年普通电脑内存为2GB为基础，按照摩尔定律来算每年增加的内存为1.2GB。计算头部必须保存在内存中，存储也不会是问题。

### 简化支付验证
一笔交易的验证并不需求全网所有机器的验证。一个用户只需要拥有网络中最长链的所有块的头部即可，它可以通过网络查询获取最长链，同时获取交易块所在的`merkle`分支。它不能自己验证交易，但是通过把这笔交易加入链中，如果有网络结点接受了它。
![image_1c33eoq8j1br6s2t1phm54b58gm.png-34.7kB][5]

那么只要是好的结点控制网络验证就是安全的，但是同时如果攻击者拥有更多的计算能力，网络也是易被攻击的。虽然网络中的结点可以自己验证交易，攻击者可以使用的最简单的攻击方式就是伪造交易，因为攻击方有大于网络的计算能力。一种策略就是接收来自网络的告警，确认交易的不一致性。经常收到支付付款的商业考虑安全性和快速的验证，还是偏向于自己运行网络节点。
### 合并以及拆分值
虽然可以单独处理每一个币，但是为每一分币创建一个交易是不明智的。为了让价值可以进行拆分或者合并，一个交易包含多个输入和输出。一般输入来自于之前的交易，或者合并新的输入，同时至少有两个输出：一个用于支付，一个用于找零，如果有的话。
![image_1c33fapag1dcfpu91lvf4v1jkq13.png-6.3kB][6]
这里需要注意的是一笔交易和之前的多个交易相关，以此类推。但是并不需要提取全部的交易历史。
### 隐私
我们考虑攻击者想要比好的结点更快的生成链的场景，这也不会让系统被随意的修改，结点不会接受无效的交易，同时好的结点也不会接受无效交易的块。攻击者只能尝试修改它自己的交易以拿回他自己花费出去的币。

攻击者和好结点之间的竞赛类似于伯努利随机漫步。如果好的结点生成的块被加了一块，那么好的结点的领先数就+1，如果攻击者生成的块被加了一块，那么好的结点的领先数就-1。

攻击者从某个块追上好的结点的概率就类似赌徒的破产游戏。假设一个赌徒以某个赤字开始赌，而且它的筹码是无限的，那么他就可以进行无限次的尝试，以达到收支平衡。我们可以如下计算赌徒达到收支平衡的概率：
$p = 好结点获取下一个块的概率$
$q = 攻击者获取下一个块的概率$
$q_z = 攻击者赶上好结点的概率，初始情况为落后z块$

$$ q_z = \begin{Bmatrix} 1 & if \space p \leq q \\ {(q/p)}^z & if \space p > q \end{Bmatrix} $$

假设$p > q$，那么攻击者赶上好结点的概率成指数级下降。
我们现在考虑接收者需要等待多久才能确定发送者不能修改交易。我们假设攻击者是支付方，想让接收者认为交易已经完成持续一小段时间，之后会支付换给他。接收者会收到告警，但于事无补。
接收者生成一对新的密钥对，同时在签名之前的很短时间内将公钥给发送方。那么这样发送方就没有足够的时间去伪造块。当交易完成时，攻击者需要同时进行替代交易的计算。

接收者需要等待交易被添加到块中，并且块被链接到$z$个块之后。他不知道攻击者伪造的进度，但是假设攻击者进行块生成的时间为块的平均生成时间，那么攻击者伪造的进度符合泊松分布
$$\lambda = z \frac{q}{p}$$

那么攻击者追赶上的概率为

$$\sum_{k=0}^{\infty}\frac{\lambda ^ k e ^{-\lambda}}{k!}\begin{Bmatrix} {(q/p)}^{z-k} & if \space k \leq z \\ 1 & if \space k > z\end{Bmatrix}$$

### 总结
我们提出了一个不基于信任的电子交易系统。我们以基于电子签名的币系统为基础，这样可以强力的控制所有权，但是并不能解决双重支付的问题。为了解决这个问题，我们使用了使用工作量证明的机制在点对点的网络中，在这种场景下，如果系统内好的结点控制着大部分的`cpu`计算力，攻击者就很难进行网络攻击。网络因为简单的规则而变得很强大。结点并没有多少通信协调。结点不需要被验证，所有的消息在网络中广播，每个结点只需要尽全力进行广播即可。结点可以随机加入或者离开网络，接受网络中的链。结点以`cpu`计算力进行投票，通过加长链表示认可之前的交易块，并且拒绝无效的块。任何需要的规则和激励都可以加入到共识机制中。

  [1]: http://static.zybuluo.com/xuchongfeng/w6m4pohx3cjlr7a15rar8rx5/image_1c2va8db31ie7sjv90lnk6is19.png
  [2]: http://static.zybuluo.com/xuchongfeng/754x9uybd5yi093cgniaewvq/image_1c30rolrdn8a1f491m731felkcv16.png
  [3]: http://static.zybuluo.com/xuchongfeng/7sqtgd7pupd84x0n4zs4orkh/image_1c30ro3orll5q0qdbg1cm3tnap.png
  [4]: http://static.zybuluo.com/xuchongfeng/k7zhruksjmsz2eqb80797x1t/image_1c33emsi11jacb4etvdogo1lqd9.png
  [5]: http://static.zybuluo.com/xuchongfeng/exhurs3ecm9lsvtnpr0fzl1c/image_1c33eoq8j1br6s2t1phm54b58gm.png
  [6]: http://static.zybuluo.com/xuchongfeng/pyh3flmyss34ifwfzflps7ka/image_1c33fapag1dcfpu91lvf4v1jkq13.png